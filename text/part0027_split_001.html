<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>未知</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图</span>
</b>
</tt>
 <tt class="calibre3">
<span class="calibre4">12-8</span>
</tt>
 <tt class="calibre3">
<b class="calibre13">
<span class="calibre4">基于</span>
</b>
</tt>
 <tt class="calibre3">
<span class="calibre4">I/O</span>
</tt>
 <tt class="calibre3">
<b class="calibre13">
<span class="calibre4">多路复用的并发</span>
</b>
</tt>
 <tt class="calibre3">
<span class="calibre4">echo</span>
</tt>
 <tt class="calibre3">
<b class="calibre13">
<span class="calibre4">服务器。每次服务器迭代都回送来自每个准备好的描述符的文本行</span>
</b>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">while (1)</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">{</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">3'i</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">/*</span>
</i>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">Wait for listening/connected descriptor(s)</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">to</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">become ready ’■/</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">pool.ready_set = pool.read_set;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">pool.nready = Select(pool.maxfd+1, fepool.ready.set, NULL, NULL, NULL);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">'34</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">/木</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">If liste-niiag descriptor ready, add new client</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">to</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">pool */</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">if</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">(FD_ISSET(listenfd,</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">&amp;pool</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">.ready_set)) {</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">connfd = Accept(listenfd, (SA *)&amp;clientaddr, feclientlen);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">add_client</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">(connfd,</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">fepool)</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">&gt;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">40</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">/■&gt; Echo a toxt line from each ready connected descriptor */</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">check_clients(&amp;pool);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">&gt;</span>
</tt>
</p>
<p height="0pt" width="3em" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/echoservers. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">图</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">12-8 (</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">续）</span>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">init__pool函数（见图12-9)初始化客户端池。clientfd数组表示已连接描述符的集合, 其中整数-1表示一个可用的槽位。初始时，已连接描述符集合是空的（第5〜7行)，而且监 听描述符是select读集合中唯一的描述符（第10〜12行)。</span>
</tt>
</p>
<p height="0pt" width="3em" class="calibre1">
<sup class="calibre7">
<small class="calibre8">
<span class="calibre18">
<tt class="calibre3">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">;</span>
</b>
</i>
</tt>
</span>
</small>
</sup>
 <span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</i>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/echoservers. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">! void init_pool(int listenfd, pool *p)</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">2 {</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">h</span>
</i>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">Initially, there are no connected descriptors</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">*/</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">int i;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">p-&gt;maxi ~ -1;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">for (i=0; i&lt; FD.SETSIZE;</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">i++)</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">p-</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">〉</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">clientfd[i] = -1;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">3</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">9</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">/*</span>
</i>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">Initially</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">,</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">listenfd is only member of select: read set.</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">伞</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">/</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">p-&gt;maxfd = listenfd;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">FD_ZER0(&amp;p-&gt;read_set);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">FD_SET(listenfd, &amp;p-&gt;read_set);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">&gt;</span>
</tt>
</span>
</p>
<p height="0pt" width="3em" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/echoservers. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">图</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">12-9 initj)ool</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">：初始化活动客户端池</span>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">add</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">一</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">clieht函数（见图12-10)添加一个新的客户端到活动客户端池中。在clientfd 数组中找到一个空槽位后，服务器将这个已连接描述符添加到数组中</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">，</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">并初始化相应的RIO读 缓冲区，这样一来我们就能够对这个描述符调用rio—readlineb (第8〜9行)。</span>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">然后</span>
</i>
</tt>
 <tt class="calibre3">
<span class="calibre4">，我们 将这个已连接描述符添加到select读集合（第12行)，并更新该池的一些全局属性。maxfd 变量（第15〜16行）记录了 select的最大文件描述符。maxi变量（第17〜18行）记录的 是到clientfd数组的最大索弓丨，这样check_clients函数就无需搜索整个数组了。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">C</span>
</tt>
</small>
</sub>
 <tt class="calibre3">
<span class="calibre4">h<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">eC</span>
</tt>
</small>
</sub>
 k_<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">C</span>
</tt>
</small>
</sub>
 lients函数（见图12-11)回送^自每个准备好的已连接描述符的一个文本行。 如果成功地从描述符读取了一个文本行，那么我们就将该文本行回送到客户端（第15〜18行)。 注意，在第15行我们维护着一个从所有客户端接收到的全部字节的累计值。如果因为客户端关 闭这个连接中它的那一端，检测到EOF,那么我们将关闭这边的连接端（第23行)，并从池中 清除掉这个描述符（第24〜25行)。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/echoservers. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">void add_client(int connfd, pool *p)</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">{</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">int i;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">p-&gt;nready__;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">for (i = 0; i &lt; FD_SETSIZE; i++)</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">/*</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">Find</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">an</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">available</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">slot</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">6</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">7</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">9</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">10</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">11</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">12</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">13</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">if (p-&gt;clientfd[i] &lt; 0) {</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">/* Add connected descriptor to the pool */</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">p-&gt;clientfd[i] = connfd;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">/* Add the descriptor to descriptor set */</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">FD_SET(connfd, &amp;p-&gt;read_set);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">and pool highwater mark */</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">h'</span>
</b>
</i>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">Update max descriptor</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">if (connfd &gt; p-&gt;maxfd) p-&gt;maxfd = connfd; if (i &gt; p-&gt;maxi) p_&gt;maxi = i; break;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">if (i -= FD</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">一</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">SETSIZE) /*</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">Cou'ldn<sup class="calibre23">
<small class="calibre8">
<span class="calibre18">
<b class="calibre13">
<span class="calibre4">1</span>
</b>
</span>
</small>
</sup>
 1 find an empty slot +./</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">app_error(<sup class="calibre23">
<small class="calibre8">
<span class="calibre18">
<tt class="calibre3">
<span class="calibre4">11</span>
</tt>
</span>
</small>
</sup>
 add_client error: Too many</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">clients")</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/echoservers. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图12-10 add client ：向池中添加一个新的客户端连接</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">code/conc/echoservers. c</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">void check_clients(pool *p)</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">If the descriptor is ready, echo a text line from it */</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">((connfd &gt; 0)</span>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">&amp;&amp;</span>
</b>
</i>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">(FD.ISSET(connfd, &amp;p-&gt;ready_set))) { p-&gt;nready--;</span>
</tt>
</span>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">if ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">byte一cut += n;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">printf("Server received %d (%d total) bytes on fd %d\n<sup class="calibre23">
<small class="calibre8">
<span class="calibre18">
<tt class="calibre3">
<span class="calibre4">M</span>
</tt>
</span>
</small>
</sup>
 ,</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">n, byte_cnt, connfd);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">Rio_writen(connfd, buf, n);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">}</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">/*</span>
</b>
</i>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">EOF detected, remove descriptor from pool</span>
</b>
</span>
 <span class="calibre2">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">*/</span>
</b>
</i>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">else {</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">int i, connfd, n; char buf[MAXLINE]; rio_t rio;</span>
</tt>
</span>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">for (i = 0; (i &lt;= p-&gt;maxi)</span>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">&amp;&amp;</span>
</b>
</i>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">(p-&gt;nready &gt; 0); i++) { connfd = p-&gt;clientfd[i]; rio = p-&gt;clientrio[i];</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">Close(connfd); FD_CLR(connfd, p-&gt;clientfd[i]</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图12-11 check_clients :为准备好的客户端连接服务</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<b class="calibre13">
<span class="calibre4">■</span>
</b>
</span>
 <span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">code/conc/echoservers. c</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<b class="calibre13">
<span class="calibre4">6</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">7</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">9</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">10</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">il</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">A</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">if</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">14</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">15</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">16</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">17</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">18</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">19</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<span class="calibre4">21</span>
</span>
 <span class="calibre2">
<b class="calibre13">
<span class="calibre4">22</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">23</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">24</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">25</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">26</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">27</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">29</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">&amp;p-&gt;read_set);</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">=-1;</span>
</tt>
</p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">根据图12-7中的有限状态模型，select函数检测到输入事件，而add一client函数创建 一个新的逻辑流（状态机)。check_clients函数通过回送输入行来执行^态转移，而且当客 户端完成文本行发送时，它还要删‘这个状态机。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">I/O多路复用技术的优劣</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">图12-8中的服务器提供了一个很好的基于I/O多路复用的事件驱动编程的优缺点示例。事 件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。例如，我 们可以设想编写一个事件驱动的并发服务器，为某些客户端提供它们需要的服务，而这对于基于 进程的并发服务器来说，是很困难的。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">另一个优点是，一个基于i/o多路复用的事件驱动服务器是运行在单一进程上下文中的，因 此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易。一个与作 为单个进程运行相关的优点是，你可以利用熟悉的调试工具，例如GDB,来调试你的并发服务 器，就像对顺序程序那样。最后，事件驱动设计常常比基于进程的设计要高效得多，因为它们不 需要进程上下文切换来调度新的流。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">事件驱动设计的一个明显的缺点就是编码复杂。我们的事件驱动的并发echo服务器需要的 代码比基于进程的服务器多三倍。不幸的是，随着并发粒度的减小，复杂性还会上升。这里的粒 度是指每个逻辑流每个时间片执行的指令数量。例如，在我们的示例并发服务器中，并发粒度就 是读一个完整的文本行所需要的指令数量。只要某个逻辑流正忙于读一个文本行，其他逻辑流就 不可能有进展。对我们的例子而言这就很好了，但是它使得我们的事件驱动服务器在“故意只发 送部分文本行然后就停止”的恶意客户端的攻击面前显得很脆弱。修改事件驱动服务器来处理部 分文本行不是一个简单的任务，但是基于进程的设计却能处理得很好,而且是自动处理的。基于 事件的设计的另一个重大缺点是它们不能充分利用多核处理器。</span>
</tt>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">_练习题12.4在如图</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">12</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">-</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">8</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">所示的服务器中，我们在每次调用select之前都立即小心地重新初始化 pool.ready_set变量。这是为什么？</span>
</tt>
</p>
<span id="filepos0006561339"></span>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre11">
<b class="calibre13">
<span class="calibre4">12.3</span>
</b>
</span>
 <span class="calibre11">
<tt class="calibre3">
<span class="calibre4">基于线程的并发编程</span>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">到目前为止，我们已经看到了两种创建并发逻辑流的方法。在第一种方法中，我们为每个流 使用了单独的进程。内核会自动调度每个进程。每个进程有它自己的私有地址空间，这使得流 共享数据很困难。在第二种方法中，我们创建自己的逻辑流，并利用i/o多路复用来显式地调度 流。因为只有一个进程，所有的流共享整个地址空间。这一节介绍第三种方法一基于线程，它 是这两种方法的混合。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">线程（thread)就是运行在进程上下文中的逻辑流。迄今在本书里，程序都是由每个进程中 一个线程组成的。但是现代系统也允许我们编写一个进程里同时运行多个线程的程序。线程由内 核自动调度。每个线程都有它自己的线程上下文（thread context),包括一个唯一的整数线程ID (Thread ID, TID)、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进 程里的线程共享该进程的整个虚拟地址空间。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">基于线程的逻辑流结合了基于进程和基于I/O多路复用的流的特性。同进程一样，线程由内 核自动调度，并且内核通过一个整数ID来识别线程。同基于I/O多路复用的流一样，多个线程 运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的整个内容，包括它的代码、数 据、堆、共享库和打开的文件。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">12.3.1线程执行模型</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">多线程的执行模型在某些方面和多进程的执行模型是相似的。思考一下图12-12中的示例。 每个进程开始生命周期时都是单一线程，这个线程称为主线程（main thread)。在某一时刻，主</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">线程创建</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">一个对等线程</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">（peer thread)，从这个时间点开始，两个线程就并发地运行。最后，因 为主线程执行一个慢速系统调用，例如read或sleep,或者因为它被系统的间隔计时器中断， 控制就会通过上下文切换传递到对等线程。对等线程会执行一段时间，然后控制传递回主线程， 依次类推。</span>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">线程1</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">(主线程<sub class="calibre24">
<small class="calibre8">
<span class="calibre18">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">4</span>
</b>
</tt>
</span>
</small>
</sub>
 ,)</span>
</b>
</tt>
</span>
</p>
</td>
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">线程2 (对等线程）</span>
</b>
</tt>
</span>
</p>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">令</span>
</b>
</tt>
</span>
</p>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20"><td class="calibre21"/>
<td class="calibre21"/>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">i</span>
</b>
</tt>
</span>
</p>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="3em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">            </span>
</b>
</tt>
</span>
</p>
</td>
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">^■…一</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
</p>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">\</span>
</b>
</i>
</span>
</p>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20"><td class="calibre21"/>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">1</span>
</b>
</tt>
</span>
</p>
</td>
</tr>
</table>
<p height="0pt" width="0pt" class="calibre28">
<tt class="calibre3">
<span class="calibre4">}线程上下文切换</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre28">
<tt class="calibre3">
<span class="calibre4">}线程上下文切换 }线程上下文切换</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图</span>
</b>
</tt>
 <tt class="calibre3">
<span class="calibre4">12-12</span>
</tt>
 <tt class="calibre3">
<b class="calibre13">
<span class="calibre4">并发线程执行</span>
</b>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">在一些重要的方面，线程执行是不同于时间 进程的。因为一个线程的上下文要比一个进 程的上下文小得多，线程的上下文切换要比 进程的上下文切换快得多。另一个不同就是 线程不像进程那样，不是按照严格的父子层 次来组织的。和一个进程相关的线程组成一 个对等（线程）池（pool),独立于其他线 程创建的线程。主线程和其他线程的区别仅 在于它总是进程中第一个运行的线程。对等 (线程）池概念的主要影响是，一个线程可 以杀死它的任何对等线程，或者等待它的任 意对等线程终止。另外，每个对等线程都能 读写相同的共享数据。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Posix 线程</span>
</b>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">Posix线程（Pthreads)是在C程序中处理线程的一个标准接口。它最早出现在1995年，而 且在大多数Unix系统上都可用。Pthreads定义了大约60个函数，允许程序创建、杀死和回收线 程，与对等线程安全地共享数据，还可以通知对等线程系统状态的变化。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">图12-13展示了一个简单的Pthreads程序。主线程创建一个对等线程，然后等待它的终止。 对等线程输出“Hello, world! \n”并且终止。当主线程检测到对等线程终止后，它就通过调 用exit终止该进程。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/hello. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">#include "csapp.h"</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">void *thread(void *vargp);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int mainO</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">pthread_t tid;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Pthread_create(&amp;tid, NULL, thread, NULL); Pthread_j oin(tid, NULL);</span>
</b>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">exit(0);</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">void *thread(void *vaxgp) /*</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">Thread routine</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">氺/</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">printf("Hello, world!\n"); return NULL;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/hello. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图</span>
</b>
</tt>
 <tt class="calibre3">
<span class="calibre4">12-13 hello.c</span>
</tt>
 <tt class="calibre3">
<b class="calibre13">
<span class="calibre4">：</span>
</b>
</tt>
 <tt class="calibre3">
<span class="calibre4">Pthreads“Hello, world!”</span>
</tt>
 <tt class="calibre3">
<b class="calibre13">
<span class="calibre4">程序</span>
</b>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">这是我们看到的第一个线程化的程序，所以让我们仔细地解析它。线程的代码和本地数据被 封装在</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">一个线程例程</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">（thread routine)中。正如第二行里的原型所示，每个线程例程都以一个通</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">用指针作为输入，并返回一个通用指针。如果想传递多个参数给线程例程，那么你应该将参数放 到一个结构中，并传递一个指向该结构的指针。相似地,如果你想要线程例程返回多个参数，你 可以返回一个指向一个结构的指针。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">第</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">4</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">行标出了主线程代码的开始。主线程声明了一个本地变量tid,它可以用来存放对等线 程的线程ID (第</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">6</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">行)。主线程通过调用pthread—create函数创建一个新的对等线程（第7 行)。当对pthread_create的调用返回时，主线^和新创建的对等线程同时运行，并且tid 包含新线程的ID。通过调用pthread_join,主线程等待对等线程终止（第</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">8</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">行)。最后，主线 程调用exit (第9行)，终止当时运行^这个进程中的所有线程（在这个示例中就只有主线程)。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">第12〜16行定义了对等线程的线程例程。它只打印一个字符串，然后就通过执行第15行 中的return语句来终止对等线程。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">12.3.3创建线程</span>
</b>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">线程通过调用pthread一create函数来创建其他线程。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">#include &lt;pthread.h&gt; typedef void *(func)(void *);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">int pthread_create(pthread_t *tid, pthread_attr_t *attr,</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">func *f, void *axg);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">返回：若成功则返回</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">0,</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">若出错则为非零。</span>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">pthread一create函数创建一个新的线程，并带着一个输入变量arg，在新线程的上下文 中运行线</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">程例程</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">f。能用attr参数来改变新创建线程的默认属性。改变这些属性已超出我们 学习的范围，并且在我们的示例中，我们总是用一个为NULL的attr参数来调用<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">P</span>
</tt>
</small>
</sub>
 thread_ create 函数。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">当pthread_<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">C</span>
</tt>
</small>
</sub>
 reate返回时，参数tid包含新创建线程的ID。新线程可以通过调用 pthread_self函数来获得它自己的线程ID。</span>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">#include &lt;pthread.h&gt;</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">pthread_t pthread</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">一</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">self(void);</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">返回</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">:</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">返回调用者的线程</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">ID</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">。</span>
</tt>
</span>
</blockquote>
</td>
</tr>
</table>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">12.3.4终止线程</span>
</b>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre28">
<tt class="calibre3">
<span class="calibre4">一个线程是以下列方式之一来终止的：</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre28">
<tt class="calibre3">
<span class="calibre4">•当顶层的线程例程返回时，线程会</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">隐式地</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">终止。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre28">
<tt class="calibre3">
<span class="calibre4">•通过调用pthread一exit函数，线程会</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">显式地</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">终止。如果主线程调用pthread一exit, 它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为thread—</span>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td colspan="2" class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">return<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">0</span>
</tt>
</small>
</sub>
</span>
</tt>
</p>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">#include &lt;pthread.h&gt;</span>
</tt>
</span>
</p>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">void pthread_exit(void *thread_return);</span>
</tt>
</span>
</p>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">返回：若成功则返回</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">0,</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">若出错则为非零。</span>
</tt>
</span>
</p>
</td>
</tr>
</table>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">•某个对等线程调用Unix的exit函数，该函数终止进程以及所有与该进程相关的线程。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">•另一个对等线程通过以当前线程ID作为参数调用pthread一cancle函数来终止当前线程。</span>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">#include &lt;pthread.li&gt;</span>
</tt>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">int pthread_cancel(pthread_t tid);</span>
</tt>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">返同：</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">:若成功则返回</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">0</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">,</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">若出错则为非零。</span>
</tt>
</span>
</blockquote>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">12.3.5</span>
</tt>
 <tt class="calibre3">
<b class="calibre13">
<span class="calibre4">回收已终止线程的资源</span>
</b>
</tt>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">线程通过调用pthread一join函数等待其他线程终止。</span>
</tt>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">#include &lt;pthread.h&gt;</span>
</tt>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">int pthread^join(pthread.t tid, void **thread_return);</span>
</tt>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">返回：</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">若成功则返回</span>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">0</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">,</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">若出错则为非零。</span>
</tt>
</span>
</blockquote>
</td>
</tr>
</table>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">pthread—join函数会阻塞，直到线程tid终止，将线程例程返回的（void*)指针赋值 为thread一return指向的位置，然后</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">回收已</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">终止线程占用的所有存储器资源。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">注意，和Unix的wait函数不同，pthread—join函数只能等待一个指定的线程终止。 没有办法让Pthread_wait等待任意一个线程终止。这使得代码更加复杂，因为它迫使我们去 使用其他一些不那么i■观的机制来检测进程的终止。实际上，Stevens在[109]中就很有说服力地 论证了这是规范中的一个错误。</span>
</tt>
</p>
<span id="filepos0006580570"></span>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">分离线程</span>
</b>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">在任何</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">一个时</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">间点上，线程是可</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">结合的</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">（joinable)或者是</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">分离的</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">（detached)。</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">一个</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">可结合 的线程能够被其他线程收回其资源和杀死。在被其他线程回收之前，它的存储器资源（例如栈） 是没有被释放的。相反，一个分离的线程是不能被其他线程回收或杀死的。它的存储器资源在它 终止时由系统自动释放。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">默认情况下，线程被创建成可结合的。为了避免存储器泄漏，每个可结合线程都应该要么被 其他线程显式地收回，要么通过调用pthread一detach函数被分离。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">pthread一detach函数分离可结合线程tid。线程能够通过以pthread一self ()为参数 的pthread一detach调用来分离它们自己。</span>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">#include &lt;pthread.h&gt;</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">int pthread_detach(pthread_t tid);</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">返回：若成功则返回</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">0,</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">若出错则为非零。</span>
</tt>
</span>
</blockquote>
</td>
</tr>
</table>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">尽管我们的一些例子会使用可结合线程，但是在现实程序中，有很好的理由要使用分离的线 程。例如，</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">一个</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">高性能Web服务器可能在每次收到Web浏览器的连接请求时都创</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">建一个</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">新的对 等线程。因为每个连接都是由一个单独的线程独立处理的，所以对于服务器而言，就很没有必要 (实际上也不愿意）显式地等待每个对等线程终止。在这种情况下，每个对等线程都应该在它开 始处理请求之前分离它自身，这样就能在它终止后回收它的存储器资源了。</span>
</tt>
</p>
<span id="filepos0006583803"></span>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">初始化线程</span>
</b>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td colspan="2" class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">pthread一once</span>
</b>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">函数允许你初始化与线程例程相关的状态。</span>
</tt>
</p>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">#include &lt;pthread.h&gt;</span>
</b>
</tt>
</span>
</p>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">pthread_once_t once</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">一</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">control</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">= PTHREAD_0NCE_INIT;</span>
</b>
</tt>
</span>
</p>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">int pthread.once(pthread_once_t</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">*once_control,</span>
</b>
</tt>
</span>
</p>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">• void (*init_routine)(void));</span>
</b>
</tt>
</span>
</p>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21">
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">总是返回</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">0</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">。</span>
</tt>
</span>
</p>
</td>
</tr>
</table>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">once_control变量是一个全局或者静态变量，总是被初始化为PTHREAD_ONCE_INIT。 当你第一次用参数once_control调用pthread_once时，它调用init_routine,这是 一个没有输入参数，也不返回什么的函数。接下来的以once_control为参数的pthread_ once调用不做任何事情。无论何时，当你需要动态初始化&gt;个线程共享的全局变量时， pthread_once函数是很有用的。我们将在12.5.5节里看到一个示例。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">一个基于线程的并发服务器</span>
</b>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">图12-14展示了基于线程的并发echo服务器的代码。整体结构类似于基于进程的设计。主 线程不断地等待连接请求，然后创建一个对等线程处理该请求。虽然代码看似简单，但是有几 个普遍而且有些微妙的问题需要我们更仔细地看一看。第一个问题是当我们调用pthread_ create时，如何将已连接描述符传递给对等线程。最明显的方法就是传递一个指向这个描述# 的指针</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">，</span>
</b>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">就像下面这样</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">connfd = Accept(listenfd, (SA *) feclientaddr, feclientlen);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Pthread</span>
</b>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">一</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">create(&amp;tid, NULL, thread, feconnfd);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">然后，我们让对等线程间接引用这个指针</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">，</span>
</b>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">并将它赋值给一个局部变量</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">，</span>
</b>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">如下所示</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">：</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">void *thread(void *vargp) {</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int connfd = *((int *)vargp);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">&gt;</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">然而，这样可能会出错，因为它在对等线程的赋值语句和主线程的accept语句间引入了 竞争（race)。如果赋值语句在下一个accept之前完成，那么对等线程中的局部变量connfd 就得到正确的描述符值。然而，如果赋值语句是在accept之后才完成的</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">，</span>
</b>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">那么对等线程中的 局部变量cormfd就得到下一次连接的描述符值。那么不幸的结果就是，现在两个线程在同一 个描述符上执行输入和输出。为了避免这种潜在的致命竞争，我们必须将每个accept返回的 已连接描述符分配到它自己的动态分配的存储器块，如第21</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">〜</span>
</b>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">22行所示。我们会在12.7.4节中 回过来讨论竞争的问题。</span>
</tt>
</p>
<p height="0pt" width="3em" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/echoservert. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">#include "csapp.h"</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<span class="calibre4">2</span>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">void echo(int connfd);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">void</span>
</b>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">氺</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">thread(void *vargp)</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">5</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int main(int argc, char **argv)</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      <sup class="calibre23">
<small class="calibre8">
<span class="calibre18">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">0</span>
</b>
</tt>
</span>
</small>
</sup>
</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">{</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int listenfd, *connfdp, port;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">socklen_t clientlen=sizeof(struct</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">sockaddr_in)</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">struct sockaddr_in clientaddr;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">pthreadst tid;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<span class="calibre4">12</span>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">if (argc</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">!=</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">2)</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">{</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">'15</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">exit(0);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">&gt;</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">port = atoi(argv[1]</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">);</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">18</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图12-14基于线程的并发echo服务器</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">listenfd = 0pen_listenfd(port); while (1) {</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">19</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">21</span>
</tt>
 <span class="calibre2">
<b class="calibre13">
<span class="calibre4">22</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">23</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">24</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">25</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">26</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">27</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">28</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">29</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">30</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">31</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">32</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">connfdp = Malloc(sizeof(int));</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">♦connfdp = Accept(listenfd, (SA *) feclientaddr, &amp;clientlen); Pthread^create(&amp;tid, NULL, thread, connfdp);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">&gt;</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">/* Thread, routine 本/ void *thread(void *vargp)</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int connfd = *((int *)vargp); Pthread_detach(pthread^self0); Free(vargp); echo(connfd);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Close(connfd); return NULL;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">.</span>
</b>
</i>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/echoservert. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图 12-14 (续）</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">另一个问题是在线程例程中避免存储器泄漏。既然我们不显式地收回线程，我们就必须分离 每个线程，使得在它终止时它的存储器资源能够被收回（第31行)。更进一步，我们必须小心释 放主线程分配的存储器块（第32行)。</span>
</tt>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">_练习题12.5在图12-5中基于进裎的服务器中，我们在两个位置小心地关闭了巳连接描述符：父进 程和子进程。然而，在图12-14中基于线程的服务器中，我们只在一个位’置关闭了巳连接描述符：对 等线程。这是为什么？</span>
</tt>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<span class="calibre11">
<b class="calibre13">
<span class="calibre4">12.4</span>
</b>
</span>
 <span class="calibre11">
<tt class="calibre3">
<span class="calibre4">多线程程序中的共享变量</span>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">从一个程序员的角度来看，线程很有吸引力的一个方面就是多个线程很容易共享相同的程序 变量。然而，这种共享也是很棘手的。为了编写正确的线程化程序，我们必须对所谓的共享以及 它是如何工作的有很清楚的了解。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">为了理解C程序中的一个变量是否是共享的，有一些基本的问题要解答：1)线程的基础存 储器模型是什么？ 2)根据这个模型</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">，</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">变量实例是如何映射到存储器的？ 3)最后，有多少线程 引用这些实例？ 一个变量是共享的，当且仅当多个线程引用这个变量的某个实例。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">为了让我们对共享的讨论具体化，我们将使用图12-15中的程序作为一个运行示例。尽管有 些人为的痕迹</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">，</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">但是它仍然值得研究，因为它说明了关于共享的许多细微之处。示例程序由一个 创建了两个对等线程的主线程组成。主线程传递一个唯一的ID给每个对等线程，每个对等线程 利用这个ID输出一条个性化的信息，以及调用该线程例程的总次数。</span>
</tt>
</p>
<p height="0pt" width="3em" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/sharing. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">#include "csapp.h"</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">#define N 2</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">void *thread(void *vargp);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">4</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">char **ptr</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">;</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">/*</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">Global</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">variable</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">*/</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<span class="calibre4">6</span>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int mainO</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图</span>
</b>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">12-15</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">说明共享不同方面的示例程序</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int i;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">pthread^t tid; char *msgs[N] = {</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">"Hello from foo", "Hello from bar"</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">ptr = msgs;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">for (i = 0; i &lt; N; i++)</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Pthread_create(fetid, NULL, thread, (void *)i); Pthread</span>
</b>
</tt>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">一</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">exit(NULL);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">void *thread(void 氺vargp)</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">25</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">26</span>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int myid = (int)vargp; static int cnt = 0;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">printf("[%d]: %s (cnt=%d)\n"</span>
</b>
</tt>
</span>
 <span class="calibre2">
<b class="calibre13">
<span class="calibre4">,</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">myid, ptr[myid]</span>
</b>
</tt>
</span>
 <span class="calibre2">
<b class="calibre13">
<span class="calibre4">,</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">++cnt); return NULL;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">28</span>
</tt>
</span>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">}</span>
</tt>
</p>
<p height="0pt" width="3em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">            </span>
</b>
</i>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/sharing. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图 12-15 (续）</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">12.4.1线程存储器模型</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">线程上下文，</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">包括线 程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其他线程一起共享 进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本（代码)、读/写数据、 堆以及所有的共享库代码和数据区域组成的。线程也共享同样的打开文件的集合。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">从实际操作的角度来说，让一个线程去读或写另一个线程的寄存器值是不可能的。另一方 面，任何线程都可以访问共享虚拟存储器的任意位置。如果某个线程修改了一个存储器位置，那 么其他每个线程最终都能在它读这个位置时发现这个变化。因此，寄存器是从不共享的，而虚拟 存储器总是共享的。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">各自独立的线程栈的存储器模型不是那么整齐清楚的。这些栈被保存在虚拟地址空间的栈区 域中，并且通常是被相应的线程独立地访问的。我们说通常而不是总是，是因为不同的线程栈是 不对其他线程设防的。所以，如果一个线程以某种方式得到一个指向其他线程栈的指针，那么它 就可以读写这个栈的任何部分。我们的示例程序在第26行展示了这一点，其中对等线程直接通 过全局变量Ptr间接引用主线程的栈的内容。</span>
</tt>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">12.4.2将变量映射到存储器</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">线程化的C程序中变量根据它们的存储类型被映射到虚拟存储器：</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">•</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">全局变量。</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">全局变量是定义在函数之外的变量。在运行时，虚拟存储器的读/写区域只包 含每个全局变量的一个实例，任何线程都可以引用。例如，第5行声明的全局变量ptr在 虚拟存储器的读/写区域中有一个运行时实例。当一个变量只有一个实例时，我们只用变 量名（在这里就是Ptr)来表示这个实例。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">•本地自动</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">变量。本地自动变量就是定义在函数内部但是没有static属性的变量。在运行 时，每个线程的栈都包含它自己的所有本地自动变量的实例。即使当多个线程执行同一个 线程例程时也是如此。例如，有一个本地变量tid的实例</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">，</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">它保存在主线程的栈中。我们 用tid.Hi来表示这个实例。再来看一个例子，本地变量myid有两个实例，一个在对等</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">线程0的栈内，另一个在对等线程1的栈内。我们将这两个实例分别表示为myid.pO和 myid.pl。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">•</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">本地静态变量。</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">本地静态变量是定义在函数内部并有static属性的变量。和全局变量一 样，虚拟存储器的读/写区域只包含在程序中声明的每个本地静态变量的一个实例。例如， 即使示例程序中的每个对等线程都在第25行声明了 cnt，在运行时，虚拟存储器的读/写 区域中也只有一个cnt的实例。每个对等线程都读和写这个实例。</span>
</tt>
</p>
<blockquote height="0pt" class="calibre26">
<blockquote width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">共享变量</span>
</tt>
</blockquote>
<span id="filepos0006606699"></span>
</blockquote>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">我们说一个变量v是共享的，当且仅当它的一个实例被一个以上的线程引用。例如，示例程 序中的变量cnt就是共享的，因为它只有一个运行时实例，并且这个实例被两个对等线程引用。 在另一方面，inyid不是共享的，因为它的两个实例中每一个都只被一个线程引用。然而，认识 到像msgs这样的本地自动变量也能被共享是很重要的。</span>
</tt>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">®练习题12.6 A.利用12.4节中的分析，为图12-15中的示例程序在下表的每个条目中填写“是”或 者“否”。在第一列中，符号v.r表示变量v的一个实例，它驻留在线程/的本地栈中，其中^要么是m (主线程)，要么是P</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">0</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">(对等线程</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">0</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">)或者pi (对等线程</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">1</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">)。</span>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">变量实例</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">主线程引用的？</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">对等线程</span>
</tt>
</span>
 <span class="calibre2">
<b class="calibre13">
<span class="calibre4">0</span>
</b>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">引用的？</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">对等线程</span>
</tt>
</span>
 <span class="calibre2">
<b class="calibre13">
<span class="calibre4">1</span>
</b>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">引用的？</span>
</tt>
</span>
</blockquote>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<b class="calibre13">
<span class="calibre4">Ptr</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">cnt</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">i .m</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">msgs.m</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">myid.po</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">myid.pl</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
</table>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">B•根据A部分的分析，变量ptr、cnt、i、msgs和myid哪些是共享的？</span>
</tt>
</p>
<span id="filepos0006610988"></span>
<p height="0pt" width="-18pt" class="calibre1">
<span class="calibre11">
<b class="calibre13">
<span class="calibre4">12.5</span>
</b>
</span>
 <span class="calibre11">
<tt class="calibre3">
<span class="calibre4">用信号量同步线程</span>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">共享变量是十分方便的，但是它们也引入了同步错误（synchronization error)的可能性。考 虑图12-16中的程序badcnt.c，它创建了两个线程，每个线程都对共享计数变量cnt加1。因 为每个线程都对计数器增加了 niters次，我们预计它的最终值是2Xnit<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">erS</span>
</tt>
</small>
</sub>
 。这看上去简单而直 接。然而,当在Linux系统上运行badcnt.c时，我们不仅得到错误的答案，而且每次得到的 答案都还不相词！</span>
</tt>
</p>
<p height="0pt" width="3em" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/badcnt. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">#include "csapp.h"</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<b class="calibre13">
<span class="calibre4">2</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">void *thread(void *vargp);</span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">/*</span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Thread</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">routine</span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">prototype</span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">*/</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">4</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">/*</span>
</b>
</i>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Global</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">shared variable */</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">volatile</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int cnt = 0; /* Counter */</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">7</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int main(int argc, char **argv)</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">{</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int niters;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">pthread_t tidl, tid2;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">12</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">/* Check input argument</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">*/</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">if (argc != 2) {</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">printf("usage: %s &lt;niters&gt;\n"，argv[0]); exit(0);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">15</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">16</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">17</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">18</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">19</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">21</span>
</tt>
 <span class="calibre2">
<b class="calibre13">
<span class="calibre4">22</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">25</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">26</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">27</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">29</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">}</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">niters = atoi(argv [1]);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">/* Create threads and wait for them to finish */</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Pthread_create(&amp;tidl, NULL, thread, feniters); Pthread.create(&amp;tid2, NULL, thread, feniters); Pthread_join(tidl， NULL);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Pthread一join(tid2, NULL);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">/* Check result */</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">if (cnt != (2 * niters))</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">printf("BOOM! cnt=%d\n", cnt);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">else</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">printf("OK cnt=%d\n", cnt);</span>
</b>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">exit(0);</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">33</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">34</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">35</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">36</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">37</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">38</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">39</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">40</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">41</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">42</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">43</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">/* Thread routine */</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">void *thread(void *vargp)</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int i, niters = *((int *)vargp);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">for (i = 0; i &lt; niters; i++) cnt++;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">return NULL;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">}</span>
</tt>
</p>
<p height="0pt" width="3em" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">code/conc/badcnt. c</span>
</b>
</i>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图 12-16 (续）</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">linux&gt;</span>
</b>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">,/badcnt</span>
</b>
</i>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">1000000 BOOM! cnt=1445085</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">linux&gt; ./badcut 1000000 BOOM! cnt=1915220</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">linux&gt;</span>
</b>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">./badcnt</span>
</b>
</i>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">1000000 BOOM! cnt=1404746</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">那么哪里出错了呢？为了清晰地理解这个问题，我们需要研究计数器循环（第</span>
</tt>
 <span class="calibre4">39</span>
 <tt class="calibre3">
<span class="calibre4">〜</span>
</tt>
 <span class="calibre4">40</span>
 <tt class="calibre3">
<span class="calibre4">行</span>
</tt>
 <span class="calibre4">)</span>
 <tt class="calibre3">
<span class="calibre4">的汇编代码，如图12-17所示。我们发现，将线程f的循环代码分解成五个部分是很有帮助的：</span>
</tt>
 <span class="calibre4">•</span>
 <tt class="calibre3">
<span class="calibre4">汉：在循环头部的指令块。</span>
</tt>
 <span class="calibre4">•</span>
 <tt class="calibre3">
<span class="calibre4">A</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">：</span>
</b>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">加载共cnt到寄存器%eax<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">i</span>
</tt>
</small>
</sub>
 的指令</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">，</span>
</b>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">这里%eax<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">i</span>
</tt>
</small>
</sub>
 表示纖/中的寄存器%eax的值。 更新（增加）％</span>
</tt>
 <span class="calibre4">eaxi</span>
 <tt class="calibre3">
<span class="calibre4">的指令。</span>
</tt>
 <span class="calibre4">•</span>
 <tt class="calibre3">
<span class="calibre4">岑：将％</span>
</tt>
 <span class="calibre4">eaxi</span>
 <tt class="calibre3">
<span class="calibre4">的更新值存回到共享变量</span>
</tt>
 <span class="calibre4">cut</span>
 <tt class="calibre3">
<span class="calibre4">的指令。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre37">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">T,</span>
</i>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">：循环尾部的指令块。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">注意头和尾只操作本地栈变量，而</span>
</tt>
 <span class="calibre4">A</span>
 <tt class="calibre3">
<span class="calibre4">、</span>
</tt>
 <span class="calibre4">^</span>
 <tt class="calibre3">
<span class="calibre4">和</span>
</tt>
 <span class="calibre4">^,•</span>
 <tt class="calibre3">
<span class="calibre4">操作共享计数器变量的内容。 当badcnt</span>
</tt>
 <span class="calibre2">
<b class="calibre13">
<span class="calibre4">•</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">c中的两个对等线程在一个单处理器上并发运行时</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">，</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">机器指令以某种顺序一个 接一个地完成。因此，每个并发执行定义了两个线程中的指令的某种全序（或者交叉)。不幸的 是，这些顺序中的一些将会产生正确结果，但是其他的则不会。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">线程</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">f</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">的汇编</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">C</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">代码</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">线程</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">/</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">的</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">C</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">代码</span>
</tt>
</span>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">for (i=0; i &lt; niters; i + + ) cnt+4-;</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<i class="calibre15">
<span class="calibre4">H</span>
</i>
 <span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">丨•.头</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Lj</span>
</b>
</i>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">: Load cnt</span>
</b>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Ui</span>
</b>
</i>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">: Update cnt</span>
</b>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Sj</span>
</b>
</i>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">: Store cnt</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">-7</span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">；</span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">: Tail</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">movl (°/,rdi) ,°/<sub class="calibre24">
<small class="calibre8">
<span class="calibre18">
<b class="calibre13">
<span class="calibre4">0</span>
</b>
</span>
</small>
</sub>
 ecx movl $0,%edx cmpl °/,ecx, %edx jge .L13</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">.Lll:</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">movl cnt (°/,rip) , °/«eax incl %eax</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">movl °/<sub class="calibre24">
<small class="calibre8">
<span class="calibre18">
<b class="calibre13">
<span class="calibre4">0</span>
</b>
</span>
</small>
</sub>
 eax, cnt (%rip)</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">incl */:edx cmpl %ecx,%edx jl .Lll</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">,L13:</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">图</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">12-17 badcmt.c</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">中计数器循环（第</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">39</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">〜</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">40</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">行）的汇编代码</span>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">这里有个关键点：</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">一般而言，你没有办法预测操作系统是否将为你的线程选择一个正确的顺 序。</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">例如，图</span>
</tt>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">12-18a</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">展示了一个正确的指令顺序的分步</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">操作。</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">在每个线程更新了共</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">享变量</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">cnt 之后，它在存储器中的值就是</span>
</tt>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">2,</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">这正是期望的值。另一方面，图</span>
</tt>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">12-18b</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">的顺序产生一个不正 确的cut的值。会发生这样的问题是因为，线程2在第5步加载cnt，是在第2步线程1加载 cnt之后，而在第6步线程1存储它的更新值之前。因此，每个线程最终都会存储一个值为1 的更新后的计数器值。我们能够借助于一种叫做</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">进度图</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">（progress graph)</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">的方法来阐明这些正确 的和不正确的指令顺序的概念，这个图我们将在下一节中介绍。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">步骤线程指令</span>
</tt>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">％</span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">eaxi 7<sub class="calibre24">
<small class="calibre8">
<span class="calibre18">
<b class="calibre13">
<span class="calibre4">8</span>
</b>
</span>
</small>
</sub>
 eax<sub class="calibre24">
<small class="calibre8">
<span class="calibre18">
<b class="calibre13">
<span class="calibre4">2</span>
</b>
</span>
</small>
</sub>
 cnt</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">步骤线程指令</span>
</tt>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">％</span>
</b>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">eaxi %eax<sub class="calibre24">
<small class="calibre8">
<span class="calibre18">
<b class="calibre13">
<span class="calibre4">2</span>
</b>
</span>
</small>
</sub>
 cnt</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1"><img src="../images/00239.jpeg" class="calibre5"/>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">^1^1^1^2^2¾^½¾¾</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1"><img src="../images/00240.jpeg" class="calibre5"/>
</p>
<p height="0pt" width="0pt" class="calibre1"><img src="../images/00241.jpeg" class="calibre5"/>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">^1^1^151^2^2^25272^1</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1"><img src="../images/00242.jpeg" class="calibre5"/>
</p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">a)</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">正确的顺序</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">b)</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">不正确的顺序</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">图</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">12-18 badcnt.c</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">中第一次循环迭代的指令顺序</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">fi练习题12.7根据badcnt.c的指令顺序完成下表：</span>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">步骤</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">线程</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">指令</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">Xeaxj</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">%eax<sub class="calibre17">
<small class="calibre8">
<span class="calibre30">
<tt class="calibre3">
<span class="calibre4">2</span>
</tt>
</span>
</small>
</sub>
</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">cnt</span>
</tt>
</blockquote>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">1</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">1</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Hi</span>
</b>
</i>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">—</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">—</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">0</span>
</tt>
</span>
</blockquote>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">2</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">1</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Li</span>
</b>
</i>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">3</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">2</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">"2</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">4</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">2</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">L<sub class="calibre29">
<small class="calibre8">
<span class="calibre30">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">2</span>
</b>
</i>
</span>
</small>
</sub>
</span>
</b>
</i>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">5</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">2</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">"2</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">6</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">2</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">h</span>
</b>
</i>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">7</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">1</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Ui</span>
</b>
</i>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">8</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">1</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Si</span>
</b>
</i>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<tt class="calibre3">
<span class="calibre4">9</span>
</tt>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">1</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Tx</span>
</b>
</i>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">10</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<tt class="calibre3">
<span class="calibre4">2</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre2">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">T<sub class="calibre29">
<small class="calibre8">
<span class="calibre30">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">2</span>
</b>
</i>
</span>
</small>
</sub>
</span>
</b>
</i>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
</table>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">这种顺序会产生一个正确的cnt值吗？</span>
</tt>
</p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">!维笛卡儿空间中的轨迹</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">线程</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">2</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">T<sub class="calibre29">
<small class="calibre8">
<span class="calibre30">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</span>
</small>
</sub>
</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">S<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</small>
</sub>
</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">U<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</small>
</sub>
</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<sup class="calibre7">
<small class="calibre8">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">L</span>
</i>
</tt>
</small>
</sup>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre2">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">H<sub class="calibre29">
<small class="calibre8">
<span class="calibre30">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</span>
</small>
</sub>
</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">线程</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">1</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">H'</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">图</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">12-19</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">Li</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">badcnt</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">U, S, T,</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">第一次循环迭代的进度图</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">线程</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">2</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">T<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</small>
</sub>
</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">S<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</small>
</sub>
</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">U<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</small>
</sub>
</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">L</span>
</i>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">H<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</small>
</sub>
</span>
</i>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">线程</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">1</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">Hi</span>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">L, U, S, T,</span>
</i>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">图</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">12-20</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">—个轨迹线示例</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">12.5.1进度图</span>
</b>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">进度图</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">（progress graph)</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">将</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">《</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">个并发线程的执行模型化为一条 线。每条轴</span>
</tt>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">A</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">对应于线程</span>
</tt>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">A:</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">的进度。每个点</span>
</tt>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">（/<sub class="calibre24">
<small class="calibre8">
<span class="calibre18">
<b class="calibre13">
<span class="calibre4">P</span>
</b>
</span>
</small>
</sub>
</span>
</b>
</span>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">h，</span>
</i>
</tt>
 <tt class="calibre3">
<span class="calibre4">…，/„)代表线程A (*=1,…，«)已经完成 了指令/々这一状态。图的原点对应于没有任何线 程完成一条指令</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">的初始</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">状态。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">图12-19展示了 badcnt.c程序第一次循环 迭代的二维进度图。水平轴对应于线程1,垂直 轴对应于线程2。点（A, 5<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">2</span>
</tt>
</small>
</sub>
 )对应于线程1完成 了 A而线程2完成了 &amp;的状态。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">进度图将指令执行模型化为从一种状态到另 一神状态的转换（transition)。转换被表示为一 条从一点到相邻点的有向边。合法的转换是向右 (线程1中的一条指令完成）或者向上（线程2中 的一条指令完成）的。两条指令不能在同一时刻 完成一34角线转换是不允许的。程序决不会反 向运行，所以向下或者向左移动的转换也是不合法的。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">一个程序的执行历史被模型化为状态空间中的一条轨迹线。图12-20展示了下面指令顺序对 应的轨迹线：</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">H\ f Li j U</span>
</i>
</tt>
 <tt class="calibre3">
<span class="calibre4">| &gt;</span>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">H</span>
</i>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</span>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">，L</span>
</i>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2<sup class="calibre23">
<small class="calibre8">
<span class="calibre18">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">9</span>
</i>
</tt>
</span>
</small>
</sup>
</span>
</i>
</tt>
</span>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">      </span>
</i>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">7\,</span>
</i>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">      </span>
</i>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">U</span>
</i>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</span>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">，S</span>
</i>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</span>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">，T</span>
</i>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">对于线程/,操作共享变量cnt内容的指令 CL,,</span>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">U<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">n</span>
</i>
</tt>
</small>
</sub>
 S)</span>
</i>
</tt>
 <tt class="calibre3">
<span class="calibre4">构成了一个（关于共享变量cnt的）</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">临界区</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">（critical section),</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">这个临界区不应该和其 他进程的临界区交替执行。换句话说，我们想要 确保每个线程在执行它的临界区中的指令时，拥 有对共</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">享变量的互斥的访问</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">（mutually exclusive access</span>
</b>
</span>
 <tt class="calibre3">
<span class="calibre4">)<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<span class="calibre4">0</span>
</tt>
</small>
</sub>
 通常这种现象称</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">为互斥</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">（mutual exclusion</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">)。</span>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">在进度图中，两个临界区的交集形成的状态 空间区域称为不</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">安全区</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">（unsafe region)。图12-21 展示了变量cnt的不安全区。注意，不安全区和 与它交界的状态相毗邻，但并不包括这些状态。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">例如，状态和（\,</span>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">U<sub class="calibre17">
<small class="calibre8">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</small>
</sub>
 )</span>
</i>
</tt>
 <tt class="calibre3">
<span class="calibre4">毗邻不安全区，</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">但是它们并不是不安全区的一部分。绕开不安全区的轨迹线叫</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">做安全轨迹线</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">（safe trajectory)。 相反，接触到任何不安全区的轨迹线就叫做</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">不安全轨迹线</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">（unsafe trajectory)。图12-21给出了 我们的示例程序badcnt.c的状态空间中的安全和不安全轨迹线。上面的轨迹线绕开了不安全 区域的左边和上边，所以是安全的。下面的轨迹线穿越不安全区，因此是不安全的。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">任何安全轨迹线都将正确地更新共享计数器。为了保证线程化程序示例的正确执行（实际上 任何共享全局数据结构的并发程序的正确执行）我们必须以某种方</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">式同步</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">线程，使它们总是有一 条安全轨迹线。一个经典的方法是基于信号量的思想，接下来我们就介绍它。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">_练习题</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">12</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">.</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">8</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">使用图</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">12</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">-</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">21</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">中的进度图，将下列轨迹线划分为安全的或者不安全的。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">L], "</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">1</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">，</span>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Si</span>
</b>
</i>
</span>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">，</span>
</i>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">"</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">2</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">，乙</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">2</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">’ "</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">2</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">，$</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">2</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">，^</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">2</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">»</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">打2，[2，</span>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Hi,</span>
</b>
</i>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</i>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">Ll, Si,</span>
</b>
</i>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">7\，"2，$2，</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">Hi, H</span>
</i>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">2</span>
</i>
</tt>
</span>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">，</span>
</i>
</tt>
 <tt class="calibre3">
<span class="calibre4">【</span>
</tt>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">2</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">，"2，</span>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">$2，Li, Ui, Si, T\, To</span>
</i>
</tt>
</p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">12.5.2信号量</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">线程2</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre28">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">写cnt的 临界区</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1"><img src="../images/00243.jpeg" class="calibre5"/>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">写cnt的临界区 图12-21安全和不安全轨迹线。临.界区的交集形成 • 了不安全区。绕开不安全区的轨迹线能够 正确更新计数器变量</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">EdsgerDijkstra,并发编程领域的先锋人物，提出了一种经典的解决同步不同执行线程问题 的方法，这种方法是基于一种叫做信 号量（semaphore)的特殊类型变量 的。信号量s是具有非负整数值的全 局变量，只能由两种特殊的操作来处 理，这两种操作称为/^和厂：</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">•PCs):如果s是非零的，那么P 将s减1,并且立即返回。如果 s为零，那么就挂起这个线程，</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">直到s变为非零，M—个K操 作会重启这个线程。在重启之 后，P操作将s减1，并将控制 返回给调用者。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<i class="calibre15">
<span class="calibre4">V(s)</span>
</i>
</tt>
 <tt class="calibre3">
<span class="calibre4">： F操作将s加1。如果有 任何线程阻塞在P操作等待s 变成非零，那么F操作会重启 这些线程中的一个，然后该线 程将s减1,完成它的P操作。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">P中的测试和减1操作是不可分割的，也就是说，一旦预测信号量s变为非零，就会将J减</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">不能有中断。F中的加1操作也是不可分割的，也就是加载、加1和存储信号量的过程中没 有中断。注意，^的定义中没有定义等待线程被重新启动的顺序。唯一的要求是F必须只能重启 一个正在等待的线程。因此，当有多个线程在等待同一个信号量时，你不能预测r操作要重启 哪一个线程。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">P和F的定义确保了一个正在运行的程序绝不可能进入这样一种状态，也就是一个正确初始 化了的信号量有一个负值。这个属性称为信号量不变性（semaphore invariant),为控制并发程序 的轨迹线提供了强有力的工具，在下一节中我们将看到。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">Posix标准定义了许多操作信号量的函数。</span>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td colspan="2" class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">#include 〈semaphore.h&gt;</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int sem_init(sem_t</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">♦sem,</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">0,</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">unsigned int value);</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int sem_wait(sem_t</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">*s);</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">/*</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">PCs) */</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">int sem_post(sem^t</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">*s);</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">/*</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">V(s) */</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">返回：若成功则为</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">0,</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">若出镨则为一</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">1</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">。</span>
</tt>
</span>
</blockquote>
</td>
</tr>
</table>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">sem一init函数将信号量sem初始化为value。每个信号量在使用前必须初始化。针对我 们的目的，中间的参数总是零。程序分别通过调用sem一wait和sem—post函数来执行和</span>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">V</span>
</i>
</tt>
 <tt class="calibre3">
<span class="calibre4">操作。为了简明，我们更喜欢使用下面这些等价的P和F的包装函数：</span>
</tt>
</p>
<table valign="top" class="calibre19">
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">#include "csapp.h"</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">1</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">void P(sem_t *s);</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">/氺</span>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Wrapper function</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">for</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">sem_wait</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">*/</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21"><br class="calibre9"/>
<br class="calibre9"/>
</td>
</tr>
<tr valign="top" class="calibre20">
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">void</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">V(sem_t *s)</span>
</b>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">;</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">/*</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Wrapper function</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">for</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">sem_post</span>
</b>
</tt>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<b class="calibre13">
<span class="calibre4">*/</span>
</b>
</span>
</blockquote>
</td>
<td class="calibre21">
<blockquote height="0pt" width="0pt" class="calibre22">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">返回：无。</span>
</tt>
</span>
</blockquote>
</td>
</tr>
</table>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p class="calibre9" style="margin:0pt; border:0pt; height:1em"> </p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">名字P和V的起源</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">Edsger Dijkstra (1930~~2002)出生于荷兰。名字尸和F来源于荷兰语单词/VMerew (测试） 和</span>
</tt>
 <tt class="calibre3">
<i class="calibre15">
<span class="calibre4">Verhogen</span>
</i>
</tt>
 <tt class="calibre3">
<span class="calibre4">(增加）。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">12.5.3使用信号量来实现互斥</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">信号量提供了一种很方便的方法来确保对共享变量的互斥访问。基本思想是将每个共享变量 (或者一组相关的共享变量）与一个信号量S (初始为1)联系起来，然后用PO)和K(s)操作将 相应的临界区包围起来。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">以这种方式来保护共享变量的信号量叫做二元信号量（binary semaphore),因为它的值总是 0或者1。以提供互斥为目的的二元信号量常常也称为互斥锁（mutex)。在一个互斥锁上执行P 操作称为对互斥锁加锁。类似地，执行K操作称为对互斥锁解锁。对一个互斥锁加了锁但是还没 有解锁的线程称为占用这个互斥锁。一个被用作一组可用资源的计数器的信号量称为计数信号量。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">图12-22中的进度图展示了我们如何利用二元信号量来正确地同步我们的计数器程序示例。 每个状态都标出了该状态中信号量s的值。关键思想是这种P和K操作的结合创建了一组状态, 叫做禁止区（forbidden region),其中s&lt;0。因为信号量的不变性，没有实际可行的轨迹线能够包 含禁止区中的状态。而且，因为禁止区完全包括了不安全区，所以没有实际可行的轨迹线能够接 触不安全区的任何部分。因此，每条实际可行的轨迹线都是安全的，而且不管运行时指令顺序是 怎样的，程序都会正确地增加计数器的值。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1"><img src="../images/00244.jpeg" class="calibre5"/>
</p>
<p height="0pt" width="0pt" class="calibre28">
<span class="calibre12">
<span class="calibre4">H!</span>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">P(s) L, U, S, V(s) T,</span>
</b>
</i>
</span>
 <span class="calibre12">
<span class="calibre4">      <sup class="calibre23">
<small class="calibre8">
<span class="calibre18">
<span class="calibre4">1</span>
</span>
</small>
</sup>
</span>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">图12-22使用信号量来互斥。s&lt;0的不可行状态定义了一个禁止区，禁止区完全包括了不安全 区，阻止了实际可行的轨迹线接触到不安全区</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">从可操作的意义上来说，由P和F操作创建的禁止区使得在任何时间点上，在被包围的临 界区中，不可能有多个线程在执行指令。换句话说，信号量操作确保了对临界区的互斥访问。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">总的来说，为了用信号量正确同步图12-16中的计数器程序示例，我们首先声明一个信号量 mutex ：</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">volatile int cnt = 0; /*</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">Coimter */</span>
</b>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">sem_t mutex;</span>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">      </span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">/</span>
</b>
</span>
 <span class="calibre2">
<tt class="calibre3">
<span class="calibre4">氺</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">Semaphore that protects counter */</span>
</b>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">然房在主例程中将mutex初始化为1 ：</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">Sem_init (&amp;mutex, 0, 1) ;</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">/*</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">mutex</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">=</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">'1</span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">      </span>
</b>
</tt>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">*/</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">最后，我们通过在线程例程中对共享变量crit的更新包围P和K操作，从而保护了它们：</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">for (i = 0; i &lt; niters; i++) {</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">P(&amp;mutex); cnt++;</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">VC&amp;mutex);</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">&gt;</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">当我们运行正确同步了的程序时，现在它每次都能产生正确的结果了。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">linux&gt;</span>
</b>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">,/goodcnt</span>
</b>
</i>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">1000000 OK cnt=2000000</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">linux&gt;</span>
</b>
</tt>
</span>
 <span class="calibre12">
<i class="calibre15">
<b class="calibre13">
<span class="calibre4">,/goodcnt</span>
</b>
</i>
</span>
 <span class="calibre12">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">1000000 OK cnt=2000000</span>
</b>
</tt>
</span>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">进度图的局限性</span>
</b>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">进度图给了我们一种较好的方法，将在单处理器上的并发程序执行可视化，也帮助我们理 解为什么需要同步。然而，它们确实也有局限性，特别是对于在多处理器上的并发执行，在多 处理器上一组</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">CPU/</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">高速缓存对共享同一个主存。多处理器的工作方式是进度图不能解释的。 特别是，一个多处理器存储系统可以处于一种状态，不对应于进度图中任何轨迹线。不管如 何，结论总是一样的：无论是在单处理器还是多处理器上运行程序，都要同步你对共享变量的 访问。</span>
</tt>
</span>
</p>
<p height="0pt" width="0pt" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">12.5.4利用信号量来调度共享资源</span>
</b>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">除了提供互斥之外，信号量的另一个重要作用是调度对共享资源的访问。在这种场景中，一 个线程用信号量操作来通知另一个线程，程序状态中的某个条件已经为真了。两个经典而有用的 例子是</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">生产者</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">-</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">消费者和读者</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">_</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">写者</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">问题。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<b class="calibre13">
<span class="calibre4">1.生产者-消费者问题</span>
</b>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">图</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">12-23给出了</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">生产者-消费者</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">问题。生产者和消费者线程共享一个有《个</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">槽的有限缓冲 区。</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">生产者线程反复地生成新</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">的项目</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">（item),并把它们插入到缓冲区中。消费者线程不断地 从缓冲区中取出这些项目，然后消费（使用）它们。也可能有多个生产者和消费者的变种。</span>
</tt>
</p>
<p height="0pt" width="0pt" class="calibre1">
<span class="calibre12">
<tt class="calibre3">
<span class="calibre4">生产者线程</span>
</tt>
</span>
 <span class="calibre12">
<b class="calibre13">
<span class="calibre4">)——►</span>
</b>
</span>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">有限的缓冲区——消费者线程</span>
</tt>
</span>
</p>
<p height="0pt" width="-18pt" class="calibre1">
<tt class="calibre3">
<span class="calibre4">图12-23生产者_消费者问题。生产者产生项目并把它们插人到一个有限的缓冲</span>
</tt>
 <span class="calibre12">
<tt class="calibre3">
<span class="calibre4">区中。</span>
</tt>
</span>
 <tt class="calibre3">
<span class="calibre4">消费者从缓 冲区中取出这些项目，然后消费它们</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但 是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的（没有空的槽 位)，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的（没有可取 用的项目），那么消费者必须等待直到有一个项目变为可用。</span>
</tt>
</p>
<p height="0pt" width="2em" class="calibre1">
<tt class="calibre3">
<span class="calibre4">生产者-消费者的相互作用在现实系统中是很普遍的。例如，在一个多媒体系统中，生 产者编码视频帧，而消费者解码并在屏幕上呈现出来。缓冲区的目的是为了减少视频流的抖动</span>
</tt>
</p>
</body>
</html>
